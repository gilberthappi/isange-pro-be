/home/happi/ims-be/prisma/schema.prisma
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int          @id @default(autoincrement())
  email     String       @unique()
  password  String
  firstName String
  lastName  String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  company   CompanyUser?
  roles     UserRoles[]
  student   Student?
}

model School {
  id          Int       @id @default(autoincrement())
  name        String
  address     String
  phoneNumber String
  email       String    @unique
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  student     Student[]
}

model Company {
  id                Int           @id @default(autoincrement())
  name              String
  address           String
  email             String        @unique
  phoneNumber       String        @unique
  economicSector    String[]
  bankName          String 
  accountNumber     String        @unique
  TIN               String        @unique
  type              String
  certificate       String        
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  CompanyUser       CompanyUser[]
}


model CompanyUser {
  id        Int      @id @default(autoincrement())
  companyId Int
  userId    Int
  title     String ?
  role      String ?
  idNumber  String ?
  idAttachment String ?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  company   Company  @relation(fields: [companyId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId])
}

enum Role {
  ADMIN
  COMPANY_ADMIN
  COMPANY_USER
  STUDENT
  TRAINER
  SUPERVISOR
  SCHOOL_ADMIN
}

model UserRoles {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id])
  role   Role
}

model Student {
  id       Int    @id @default(autoincrement())
  userId   Int    @unique
  user     User   @relation(fields: [userId], references: [id])
  schoolId Int
  school   School @relation(fields: [schoolId], references: [id])
}

model Sector {
  id       Int      @id @default(autoincrement())
  name     String
  threads  Thread[]
}

model Thread {
  id       Int      @id @default(autoincrement())
  name     String
  levels   Level[]
  sector   Sector   @relation(fields: [sectorId], references: [id])
  sectorId Int
}

model Level {
  id       Int      @id @default(autoincrement())
  name     String
  thread   Thread   @relation(fields: [threadId], references: [id])
  threadId Int
}


/home/happi/ims-be/src/config/env.ts
import dotenv from "dotenv";
dotenv.config();
export const appEnv = {
  cloudinaryApiKey: process.env.CLOUDINARY_API_KEY,
  cloudinaryApiSecret: process.env.CLOUDINARY_API_SECRET,
  cloudName: process.env.CLOUD_NAME,
};

/home/happi/ims-be/src/controllers/schoolController.ts
import { Body, Get, Post, Put, Delete, Route, Tags, Security, Middlewares } from "tsoa";
import { SchoolService } from "../services/schoolService";
import { ISchool } from "../utils/interfaces/common";
import { checkRole } from "../middlewares/checkRole";
import { roles } from "../utils/roles";

@Tags("Schools")
@Security("jwt")
@Route("/api/schools")
export class SchoolController {
  @Get("/")
  public getSchools() {
    return SchoolService.getSchools();
  }

  @Get("/{id}")
  public getSchool(id: number) {
    return SchoolService.getSchool(id);
  }

  @Post("/")
  @Middlewares(checkRole(roles.ADMIN))
  public createSchool(@Body() school: ISchool) {
    return SchoolService.createSchool(school);
  }

  @Put("/{id}")
  @Middlewares(checkRole(roles.ADMIN,roles.SCHOOL_ADMIN))
  public updateSchool(id: number, @Body() school: Partial<ISchool>) {
    return SchoolService.updateSchool(id, school);
  }

  @Delete("/{id}")
  @Middlewares(checkRole(roles.ADMIN))
  public deleteSchool(id: number) {
    return SchoolService.deleteSchool(id);
  }

  @Delete("/")
  public deleteAllSchools() {
    return SchoolService.deleteAllSchools();
  }
  
}

/home/happi/ims-be/src/events/school.ts
import { hashSync } from "bcrypt";
import { prisma } from "../utils/client";
import { TSchool } from "../utils/interfaces/common";
import { roles } from "../utils/roles";

export const schoolCreatedHandler = async (school: TSchool) => {
  try {
    await prisma.$transaction(async (tx) => {
      const schoolAdmin = await tx.user.create({
        data: {
          firstName: school.name,
          lastName: "N/A",
          email: school.email,
          password: hashSync("Pa$$word1", 10),
        },
      });

      if (!schoolAdmin) {
        throw new Error("Failed to create new School Admin");
      }

      const assignRole = await tx.userRoles.create({
        data: { userId: schoolAdmin.id, role: roles.SCHOOL_ADMIN },
      });

      if (!assignRole) {
        throw new Error("Failed to assign role to school Admin");
      }
    });
  } catch (err) {
    prisma.$disconnect();
  }
};

/home/happi/ims-be/src/middlewares/checkRole.ts
import { NextFunction, Request, Response } from 'express';
import AppError from '../utils/error';
import { roles } from '../utils/roles';

type Role =  keyof typeof roles;
export const checkRole =
  (...persmissions: Role[]) =>
  (req: Request, res: Response, next: NextFunction) => {
    console.log("oooooooooooooooooo");
    if(!req.user?.roles){
      throw new AppError("Access denied",403);
    }
    const isArrowed = req.user?.roles.some((permission) =>
    persmissions.includes(permission.role as Role),
    );
    if (!isArrowed) {
      throw new AppError('Access Denied', 403);
    }
    return next();
  };

/home/happi/ims-be/src/middlewares/validator.ts


import { Request, Response, NextFunction } from "express";
import { AnyZodObject, ZodError } from "zod";

const validate =
  (schema: AnyZodObject) => async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync(req.body);
      return next();
    } catch (error) {
      const errorMap = error as ZodError;
      const validationErrors = errorMap.issues.map((issue) => {
        return { message: issue.message, field: issue.path };
      });
      return res.status(400).json({ errors: validationErrors,mess:req.body});
    }
  };
export default validate;

/home/happi/ims-be/src/services/schoolService.ts

import { prisma } from "../utils/client";
import { ISchool, IResponse } from "../utils/interfaces/common";
import { schoolSchema } from "../utils/typeSchemas/school";
import { Emitter } from "../events";
import { EventType } from "../events/types";

export class SchoolService {
  public static async getSchools(): Promise<IResponse<ISchool[]>> {
    try {
      const schools = await prisma.school.findMany();
      return {
        message: "Schools fetched successfully",
        statusCode: 200,
        data: schools,
      };
    } catch (error: any) {
      return {
        message: error.message,
        statusCode: 500,
        error,
      };
    }
  }

  public static async getSchool(id: number): Promise<IResponse<ISchool>> {
    try {
      const school = await prisma.school.findUnique({ where: { id } });
      if (!school) {
        return {
          message: "School not found",
          statusCode: 404,
        };
      }
      return {
        message: "School fetched successfully",
        statusCode: 200,
        data: school,
      };
    } catch (error: any) {
      return {
        message: error.message,
        statusCode: 500,
        error,
      };
    }
  }

  public static async createSchool(
    school: ISchool
  ): Promise<IResponse<ISchool>> {
    try {
      const emailTaken = await prisma.school.findFirst({
        where: { email: school.email },
      });
      if (emailTaken) {
        return {
          message: "Email already taken",
          statusCode: 409,
        };
      }
      const newSchool = await prisma.school.create({ data: school });

      Emitter.emit(EventType.SCHOOL_CREATED, newSchool);

      return {
        message: "School Created Successfully!!",
        statusCode: 201,
        data: newSchool,
      };
    } catch (error: any) {
      return {
        message: error.message,
        statusCode: 500,
        error,
      };
    }
  }

  public static async updateSchool(
    id: number,
    school: Partial<ISchool>
  ): Promise<IResponse<ISchool>> {
    try {
      const updatedSchool = await prisma.school.update({
        where: { id },
        data: school,
      });
      return {
        message: "School updated successfully",
        statusCode: 200,
        data: updatedSchool,
      };
    } catch (error: any) {
      return {
        message: error.message,
        statusCode: 500,
        error,
      };
    }
  }

  public static async deleteSchool(id: number): Promise<IResponse<null>> {
    try {
      await prisma.school.delete({ where: { id } });
      return {
        message: "School deleted successfully",
        statusCode: 200,
      };
    } catch (error: any) {
      return {
        message: error.message,
        statusCode: 500,
        error,
      };
    }
  }

  public static async deleteAllSchools(): Promise<IResponse<null>> {
    try {
      await prisma.school.deleteMany();
      return {
        message: "All Schools deleted successfully",
        statusCode: 200,
      };
    } catch (error: any) {
      return {
        message: error.message,
        statusCode: 500,
        error,
      };
    }
  }
}

/home/happi/ims-be/src/utils/interfaces/common.ts
import type { Prisma } from "@prisma/client";
import { prisma } from "../client";
import { TsoaResponse } from "tsoa";

export interface IResponse<T> {
  statusCode: number;
  message: string;
  error?: unknown;
  data?: T;
}

export type TSchool = {
  id: number;
  name: string;
  address: string;
  phoneNumber: string;
  email: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type TCompany ={
    id: number;
    name: string;
    address: string;
    phoneNumber: string;
    email: string;
    economicSector: string[] | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
}
export type TUser = {
  id: number;
  email: string;
  firstName: string;
  lastName: string;
  password: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  roles?: { id: number; role: string; userId: number }[];
};
export type TStudent = {
  id: number;
  firstName: string;
  lastName: string;
  password: string;
  email: string;
  schoolId: number;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};
export interface IUser extends Omit<TUser, "id" | "createdAt" | "updatedAt"> {}
export interface ISchool extends Omit<TSchool, "id" | "createdAt" | "updatedAt"> {}
export interface ILoginResponse
  extends Omit<TUser, "password" | "createdAt" | "updatedAt" | "roles"> {
  token: string;
}
export interface IStudent extends Omit<TStudent, "id" | "createdAt" | "updatedAt"> {}
export interface IUser extends Omit<TUser, 'id' | 'createdAt' | 'updatedAt'> { };
export type ILoginUser = Pick<IUser, "email" | "password">
export interface ISchool extends Omit<TSchool, 'id' | 'createdAt' | 'updatedAt'> { };
export type TErrorResponse = TsoaResponse<400 | 401 | 500, IResponse<{ message: string }>>
export interface ILoginResponse extends Omit<TUser,"password"|"createdAt"|"updatedAt"|"roles"> {token: string};
export interface CreateCompanyDto {
    company: {
      name: string;
      address: string;
      email: string;
      phoneNumber: string;
      bankName: string;
      accountNumber: string;
      TIN: string;
      economicSector: string[];
      certificate: Express.Multer.File | string
      type: string;
    };
    contactPerson: {
      firstName: string;
      lastName: string;
      email: string;
      phoneNumber: string;
      title: string;
      role: string;
      idNumber: string;
      idAttachment: Express.Multer.File | string
    };
  }
  
/home/happi/ims-be/src/utils/loggers/loggingMiddleware.ts
import { NextFunction, Request, Response } from "express";

export async function loggerMiddleware(req: Request, res: Response, next: NextFunction) {
    console.log(`new request at: ${req.url} , body`, req.body);
    next();
}

/home/happi/ims-be/src/utils/typeSchemas/school.ts

import z from 'zod'

export const schoolSchema = z.object({
    name: z.string(),
    address: z.string(),
    phoneNumber: z.string(),
    email: z.string().email(),
})

/home/happi/ims-be/src/utils/authentication.ts
import * as express from "express";
import AppError from "./error";
import { verifyToken } from "./jwt";
import { prisma } from "./client";
import { TUser } from "./interfaces/common";

export const expressAuthentication =(
  request: express.Request,
  securityName: string,
  scopes?: string[]
) =>{
  if (securityName === "jwt") {
    const token = request.headers["authorization"] as string;
    return new Promise(async(resolve, reject) => {
      try {
        if (!token) {
          reject(new AppError("No token provided",401));
          return;
        }
        const email = (await verifyToken(token)) as string;
        const user = await prisma.user.findFirst({ where: { email },include:{roles:true} });
        request.user = user as TUser;
        resolve(user)
      } catch (error) {
        reject(new AppError("Not Authorized",403));
      }
    });
  }
}
/home/happi/ims-be/src/utils/client.ts


import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient({
    errorFormat: "minimal"
})

/home/happi/ims-be/src/utils/cloudinary.ts
import { v2 as cloudinary } from "cloudinary";
import { CloudinaryStorage } from "multer-storage-cloudinary";
import multer from "multer";
import { Request } from "express";
import { v4 } from "uuid";
import { appEnv } from "../config/env";

cloudinary.config({
    api_key: appEnv.cloudinaryApiKey,
    api_secret: appEnv.cloudinaryApiSecret,
    cloud_name: appEnv.cloudName,
});
const storage = new CloudinaryStorage({
    cloudinary: cloudinary,
    params: (req: Request, file: Express.Multer.File) => ({
        public_id: v4(),
        folder: "ims",
    }),
});

const upload = multer({ storage: storage });
export default upload;

/home/happi/ims-be/src/utils/error.ts
class AppError extends Error {
  public status: number;

  constructor(message: string, status: number) {
    super(message);
    this.status = status;
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

export interface IValidationError{
  field: string;
  error: string;
}
export class ValidationError extends Error {
  constructor(message: IValidationError[]) {
    super(JSON.stringify(message));
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

export default AppError;
/home/happi/ims-be/src/utils/jwt.ts
import jwt from 'jsonwebtoken';

export const verifyToken = async (
  data: string,
): Promise<string | jwt.JwtPayload> => {
  return jwt.verify(data,process.env.JWT_SECRET!);
};
/home/happi/ims-be/src/utils/prettyPrisma.ts
import { ZodError } from "zod";

export const prettyPrismaErrorMessage = (error: ZodError<any>) => error.errors.reduce((msg, currMsg) => `${msg}${currMsg.message} `, '')


/home/happi/ims-be/src/utils/roles.ts
export  const enum roles{
  ADMIN = "ADMIN",
  COMPANY_ADMIN = "COMPANY_ADMIN",
  COMPANY_USER = "COMPANY_USER",
  STUDENT = "STUDENT",
  TRAINER = "TRAINER",
  SUPERVISOR = "SUPERVISOR",
  SCHOOL_ADMIN = "SCHOOL_ADMIN",
}


/home/happi/ims-be/src/index.ts
import express, {
  json,
  urlencoded,
  Response as ExResponse,
  Request as ExRequest,
  NextFunction,
} from "express";
// @ts-ignore
import { RegisterRoutes } from "../build/routes";
import swaggerUi from "swagger-ui-express";
import { ValidateError } from "tsoa";
import cors from "cors";
import { TUser } from "./utils/interfaces/common";
import AppError, { ValidationError } from "./utils/error";

declare module "express" {
  interface Request {
    user?: TUser;
  }
}

const app = express();
const PORT = process.env.PORT || 3000;
app.use(
  urlencoded({
    extended: true,
  })
);

app.use(json());
app.use(cors());
app.use("/docs", swaggerUi.serve, async (_req: ExRequest, res: ExResponse) => {
  return res.send(
    // @ts-ignore
    swaggerUi.generateHTML(await import("../build/swagger.json"))
  );
});

RegisterRoutes(app);

app.use(function errorHandler(
  err: unknown,
  req: ExRequest,
  res: ExResponse,
  next: NextFunction
): ExResponse | void {
  if (err instanceof AppError) {
    return res.status(err.status).json({
      status: err.status,
      message: err.message,
    });
  }

  if(err instanceof ValidationError){
    return res.status(400).json({error:"validate",data:JSON.parse(err.message)});
  }
  if (err instanceof Error) {
    return res.status(500).json({
      message: err.message ?? "Internal server error",
      status: 500,
    });
  }
  next();
});

app.listen(PORT, () => console.log(`API running on PORT ${PORT} wow!s`));

